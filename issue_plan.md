## What we are implementing:

We are going to work on an issues competition that we will setup for the Gittensor incentive mechanism that validators will run. This will be an end to end system that will require UI work, API work, DB changes, Subnet IM (incentive mechanism) changes, smart contract development, etc. The goal is to force miners to compete head to head (or in limited pool sizes) to resolve a github issue that belongs to an open source repository. The solver of the issue is the one who will be paid out a "bounty" that is formed by accumulated emissions that would otherwise be recycled.

All work for each respective repo should be checked out onto a branch called `issues-v1`.
Some repos dont have a test branch to checkout from (gt-utils) so use `main`. But das, ui, docs-ui, gittensor-db, gittensor all have env specific branches (`test`) 

This is the expected functionality via a story:
"
Smart contract:
A WASM smart contract should be deployed on the subtensor blockchain. This smart contract will facilitate the upkeeping of issues, bounty payouts, etc. How this will work? There will be an ownerOnly function where issues can be registered. What is taken on issue registration is: (Github Issue identification (link, full repo name + issue number, something), BountyAmount). The smart contract will be registered as a neuron and will therefore be able to be allocated emissions by validators. This means that the smart contract can be registered as a "miner" and allocated emissions by validators (alpha tokens) which is how the smart contract will orchestrate the flow of the bounty amounts. When the smart contract recieves emissions, it should simply recognize its balance and do: Do I have bounties to allocate this alpha to? If so, then fill those pools first, if not then recycle the alpha. This should be an automatic process that is always happening. The smart contract will need to have additional functions like: Get issues -> returns issues + bounty amounts. Vote issue -> Whitelisted validators can vote an issue as (solved, solvedby) or (cancelled, reason) and then if solved, it has a payout function to pay whoever it was solved by (uses transferFrom) and if it was cancelled, then recycle that bounty amount and update the list. There may need to be an owner only function to manage the validator whitelist. ideally, the validator weight is based off of stake and we don't do a majority rule approach. This contract should be made in the gittensor repository under some new smart-contracts directory.

It can be assumed that I will be seeding the smart contract with issues by calling the register issue function and no abstraction for calling this is needed. I can do it via CLI, but an issue registration script that has checks (valid github issue, etc) and automatically calls this smart contract function may be ideal. Any such scripts belong to gt-utils.

The subnet incentive mechanism will need to be modularized with it's work as well. We effectively want to take the current `get_rewards()` function in rewards.py and like bundle that up as `get_rewards_for_oss_contributions`. Ideally all of this existing scoring code in evaluation and whatnot should be shaped up into an `oss_contributions` folder so we can modularize the 2 different things that the validator is scoring. Similarly, to the entry point of `get_rewards_for_oss_contributions`, we should make an entry point for the validator to do `get_rewards_for_issue_competitions` that encapsulates all of the logic we'll need. 
One complication is that we need some means of validator consensus when it comes to assigning the issue competition to 2 miners. Preferably, we don't want to assign them, rather we want them to opt in (with some conditions). If we assigned them, how would we do it? If it was random selection in any way (even if probability driven) then validator consensus wouldn't happen. Additionally, these validators are stateless with how they are set up. Each time they run, it is a present state run that knows nothing of the past and only evaluates the data at hand. For this issue, it may be necessary to leverage the smart contract for it's states. Here's the idea:

Miners have some means (TUI tool) to be able to query the smart contract and see available issues and their bounties or fulfilled issues + bounties. Then they can select one issue that they'd like to enroll to compete for and this will be included in their response to validators similar to how they currently return a GitPatSynapse. This should get 'real time data' by querying the smart contract.

There should be some function that: 
Validators should somehow be able to analyze last Xd (90D max), maybe we'll do 30-60 (some CONSTANT) and this analysis will produce the elo ranks of miners based on their performance head to head from the last x number of days.
Validators will take this response of desired competition and sort the miners by ELO descending. Miners that are not occupied to a current issue will have priority for issue assignments. When an assignment is made, validators will post that selection to the smart contract and then the smart contract says when majority (by count or stake) hits, then it will complete that assignment (enforces consensus) and then when 2 are assigned the compeititon starts. It may be better if competition only starts when a pair can be assigned and assignments happen in pairs (competitiors) rather than indiviudal assignments.
I think that it also makes sense to give some submission window where the PR that solves this has to be created after the submission window (issue start + 2 days) or something so that the miners have adequate time to compete for a solution and not rush their attempt. This should all be info that is displayed in TUI meaning its offered by smart contract and also be displayed in UI later.
It is the theme though that states of this belong to the smart contract and the validator queries accordingly and performs logic then re-interacts with the smart contract accordingly.
So, validator now does:
- Analyze last x days of performance for elo ranks
- Queries and takes responses of desired competition and sort the miners by ELO descending. Miners that are not occupied to a current issue (smart contract tells us this) will have priority for issue assignments. When an assignment is made, validators will post that competing pair selection to the smart contract and then the smart contract says when majority (by count or stake) hits, then it will complete that assignment (enforces consensus) and then when 2 are assigned the compeititon starts. Competition earliest submission deadline is start + x days (configurable smart contract constant - owner only adjustable)
- Does a solution detection loop where it queries the github api accordingly in order to find out if a miners PR solved a specific issue and if it does detect that they indeed did, it calls the smart contract accordingly.
_Note: I think that there's a lot more to be hashed out here. Let's do that. I want to give the miner options to skip, but also a penalty be incurred if x reps or time has passed by without their enrollemnt. This has to be done strategically with the stateless validator, so maybe time based? I'd also say once elo gets below a specific threshold they no longer really even get the opporuntity to resolve an issue (put a time decay on this so it's not permanent). Maybe a rolling EMA of performance or something
Collateral deposits  may not be crazy down the line. win, get it back. lose, it's gone.  Why this? Really may get valuable contributions out of miners. Right now their only consequence is what I spelled out which is issue resolvement failure = lesser elo score = less likely to be picked for higher bounty issues (if at all) = less opportunities. **But we should ideate more dire consequences**. How can we make it very worth it for miners to submit absolutely quality solutions that truly solve the problem? Lets chat about this more and flush out all of the changes here, end to end._

All issue competition related data should be stored in the database somehow. Table definitions of course should remain up to date in gittensor-db which now has a CI pipeline. This includes the extrinsics of the smart contract (events that happen), the active issues, who those are assigned to, the amounts, timestamps, etc. This database has nothing to do with how anything functionally works but just has to do with serving this under the hood information (db -> api -> ui (dashboard)). This is all really the cosmetic layer and is just information serving. It also may include the need for cron scheduled scripts to scrape information which can be done by creating scripts in gt-utils.

Similarly, the API layer just needs to have sufficient endpoints to serve the information related to the issue competition data. It should be modularized within the src folder so that it is distinguished as like a new feature of the system. This means it should have its own isolated endpoints and files really. Nothing should be baked into existing files too much in this API work.

Additionally, the UI layer will just need to have some dummy components that show how this information can be displayed. I'll leave it up to you to follow similar themes and practices that have been set forth, but the only real task here is to just come up with a quick UI that serves all of the information available. we just need a new tab on the left nav bar for issues and then on that page gittensor.io/issues is where your mocks of components and a page can go. I will take this mock UI and hand it off to a UI dev that will feature complete it from here. That UI dev is UI only and has no knowledge of API endpoint offerings + DB data so it is key for you to really make mock components that display ALL of the available data so it is very clear for this handoff. Your work should be modularized within the src folder so that it is distinguished as like a new feature of the system. This means it should have its own isolated components and files really. However re-use applicable UI components when needed of course. But nothing should be baked into existing files too much in this UI work. _Note: The coolest thing that i'd like to see developed here is some type of competition aspect that clearly shows miner A matched up versus miner B_
"

--- 

## Planning instructions:

Be sure to carefully go through system by system and ensure that everything needed in the expecatation is present and planned. If something seems to be missing, like a DB table, endpoint, logic for __ edge case, then add it as a proposal. We want to remind ourselves how this system will work end to end and consistently cater to that expectation.

The plan should be so clear and thorough that we have an understanding of every function needed for a smart contract and why each one. Each system should be planned with such care and understanding of how it impacts the next system or will be used by the next system. i.e: smart contract has *y* function -> gt-utils cron script gets extrinsic data from *y* function and stores to table *t* -> api serves info from table *t* for ui's purpose, *u*. 

- Plan agent, skill, and tool usage accordingly. Also break the end goal into modular task that ensures completion of every thing in the correct order.

- Lets plan for checkpoints or milestones. At checkpoints/milestones, we will pause, review the code and implementations, address questions, link resources, etc. Once a milestone is complete, we will move onto the next one. 1-10 milestones should be implemented. Milestones can be an aggregation of things, they don't have to be ultramodular and should not be. They should not be confined to just one repository, etc. Plan them according to the fact that we want lots of background running agents, etc throughout this development process.

- Plan this out by leveraging a spec file or multiple for each modular task. The better your spec of every detail, the better for development.

**Finally, it is important that you ULTRATHINK. We want to complete the majority of this development in one attempt with the only lingering implementations to be design decisions.** It is imperative that you step back and think of every individual system from the end to end functionality and all participating parties. System design diagrams will be your friend in the planning step.

**This should be 70% planning with so many questions that must be thought about and understood** and 30% implementing. That's how much planning i expect.